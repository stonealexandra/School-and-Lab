---
title: "Final Project"
author: "Alexandra Stone"
date: "December 5, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#load necessary packages
library(readr)
library(dplyr)
library(tidyverse)
library(stringr)
library(readxl)

#set working directory 
setwd("c:/Users/user/Desktop")

#load crimeData and states into DF
na.vals <- c("", "NA", "n/a", "N/A", "none", "NULL")
crimeData <- read_csv("C:/Users/user/Desktop/SHR76_17.csv", na = na.vals)
```

Information on the variables for the crimeData are taken from the MAP website's PDF:

Murder Accountability Project
Data Dictionary for amplified Supplementary Homicide Report
ID - Unique record identifier generated by MAP based upon the YEAR, MONTH, INCIDENT and ORI code in the report. Alphanumeric 16-character format (A16).
CNTYFIPS - The Census Bureau's Federal Information Processing Standards (FIPS) code designating the state and county of the reporting law enforcement agency. When using the SPSS format file (extension=.sav), the label name of the county is associated with a five-digit string variable. When using the Comma Separated Values format file (file extension=.csv) the original FIPS coding is replaced with the label indicating the county and state. (A15).
ORI - The alphanumeric variable describing the Originating Agency making the report. The first two digits describe the state of the Originating Agency, the next three digits usually represent the county in which the agency is located (according to an FBI numbering scheme) and the last two digits describe the agency's number within the state. (A7).
STATE - The alphanumeric variable describing the state of the Originating Agency making the report. In most cases, the state was coded in a two-digit naming scheme. In the SPSS version of the file, the full name of the state is associated as a label so that "AK" = "Alaska" or "AL" = "Alabama." (A6).
AGENCY - The alphanumeric variable describing the name of the law enforcement agency making the report. (A450).
AGENTYPE - The one-digit numeric code describing the type of law enforcement agency making the report so that 1=Sheriff, 2=County Police, 3=Municipality, 5=Primary State Law Enforcement usually meaning the State Police, 6=Special Police, 7=Constable, 8=Tribal Police, 9=Regional Police. When using the Comma Separated Values format file (file extension=.csv) the original FBI numbering scheme is replaced with the alphanumeric label. (F1.0).
SOURCE - MAP-generated identifier if record provided by FBI (SOURCE=1) or was obtained by MAP under the Freedom of Information Act from an Agency not participating in SHR reporting to the FBI (SOURCE=0). Numeric single digit format (F1.0).
SOLVED - MAP-generated indicator whether Offender was identified at time report was made (SOLVED=1) or not identified (SOLVED=0). Numeric single digit format (F1.0).
YEAR - Year of homicide (or when victim's body was recovered.) Numeric four digit (F4.0).
STATENAME = Alphanumeric variable describing the original FBI naming and abbreviating scheme for the state of the reporting agency. (A6).
MONTH - The month of homicide occurrence or when the victim's body was recovered. Numeric two digit (F2.0). (01=January, 02=February . 12=December).
INCIDENT - A three-digit number describing the case number within the month in which a homicide occurred. This does not necessarily correspond to the actual case number used in-house by police agencies. It is used to assist in building a unique record number for each case and to differentiate each case reported within the same month. (F3.0).
ACTIONTYPE - A numeric variable describing the nature of the report received. Whether it was: 0=Normal Update or 1=Adjustment to a previous report. F1.0)
HOMICIDE - An alphanumeric variable defining whether the report was "A" = "Murder or Non-negligent manslaughter" or "B" = "Manslaughter by Negligence." (A1).
SITUATION - An alphanumeric variable defining whether the crime had a single victim or multiple victims and whether there was a single offender, multiple offenders or the number of offenders was unknown. So that "A" = "Single Victim/Single Offender" and "B" = "Single Victim/Unknown Offender" and so forth. (A1).
VICAGE - A three-digit numeric variable describing the age in years of the victim. To allow for simpler mathematical calculations, MAP has changed the original alphanumeric coding of "NB" for new born and "BB" for infant to a numeric value of zero to indicate the victim had not achieved a full year of life. A value of 99, as in the original numbering scheme, represents all victims 99 or older. A value of 999 represents victims whose age was not reported, usually because the victim was unidentified and the age was unknown. (F3.0)
VICSEX - An alphanumeric variable representing whether the victim was "M" = "Male" or "F" = "Female" or "U" indicating "Unknown" gender, usually for conditions in which incomplete remains were recovered. (A1).
VICRACE - An alphanumeric variable representing whether the victim was "A" = "Asian or Pacific Islander" or "B" = "Black" or "I" = "American Indian or Alaskan Native" or "W" = "White" or "U" victim was of "Unknown" race. (A1).
VICETHNIC - An alphanumeric variable representing whether the victim was "H" = "Hispanic Origin" or "N" = "Not of Hispanic Origin" or "U" = "Unknown or Not Reported." It should be noted that many agencies decline reporting the ethnicity of victims and offenders. A1.
OFFAGE - A three-digit numeric variable describing the age in years of the offender. When the offender was not identified at the time of the report, age was reported as 999. A value of 99 represents all offenders 99 or older. (F3.0)
OFFSEX - An alphanumeric variable representing whether the offender was "M"="Male" or "F"="Female" or "U" indicating "Unknown" gender, usually in conditions in which the offender had not been identified at the time of the report. (A1).
OFFRACE - An alphanumeric variable representing whether the offender was "A" = "Asian or Pacific Islander" or "B" = "Black" or "I" = "American Indian or Alaskan Native" or "W" = "White" or "U" = "Unknown" race, usually in conditions in which the offender had not been identified at the time of the report. (A1).
OFFETHNIC - An alphanumeric variable representing whether the offender was "H" = "Hispanic Origin" or "N" = "Not of Hispanic Origin" or "U" = "Unknown or Not Reported." It should be noted that many agencies decline reporting the ethnicity of victims and offenders. (A1).
WEAPON - A two-digit numeric variable representing the weapon used in the crime. (F2.0) Under this system, weapons are coded as:
11 = Firearm, type not stated
12 = Handgun - pistol, revolver, etc.
13 = Rifle
14 = Shotgun
15 = Other gun
20 = Knife or cutting instrument
30 = Blunt object - hammer, club, etc.
40 = Personal weapons, including beating
50 = Poison, does not include gas
55 = Pushed or thrown out of window
60 = Explosives
65 = Fire
70 = Narcotics or drugs, sleeping pills
75 = Drowning
80 = Strangulation or hanging
85 = Asphyxiation - includes death by gas
90 = Other or type unknown weapon
RELATIONSHIP - An alphanumeric variable describing the relationship between the victim and the offender, if any. (A2). Under the original FBI criteria, relationship is coded as:
"AQ" = "Acquaintance"
"BF" = "Boyfriend"
"BR" = "Brother"
"CH" = "Common-law husband"
"CW" = "Common-law wife"
"DA" = "Daughter"
"EE" = "Employee"
"ER" = "Employer"
"FA" = "Father"
"FR" = "Friend"
"GF" = "Girlfriend"
"HO" = "Homosexual relationship"
"HU" = "Husband"
"IL" = "In-law"
"MO" = "Mother"
"NE" = "Neighbor"
"OF" = "Other family"
"OK" = "Other - known to victim"
"SD" = "Stepdaughter"
"SF" = "Stepfather"
"SI" = "Sister"
"SM" = "Stepmother"
"SO" = "Son"
"SS" = "Stepson"
"ST" = "Stranger"
"UN" = "Relationship not determined"
"WI" = "Wife"
"XH" = "Ex-husband"
"XW" = "Ex-wife"
CIRCUMSTANCES - A two-digit numeric variable representing the circumstances (or theory) for the crime. (F2.0). The circumstances under the original FBI coding scheme are represented as:
2 = Rape
3 = Robbery
5 = Burglary
6 = Larceny
7 = Motor vehicle theft
9 = Arson
10 = Prostitution and commercialized vice
17 = Other sex offense
18 = Narcotic drug laws
19 = Gambling
26 = Other - not specified
32 = Abortion
40 = Lovers triangle
41 = Child killed by babysitter
42 = Brawl due to influence of alcohol
43 = Brawl due to influence of narcotics
44 = Argument over money or property
45 = Other arguments
46 = Gangland killings
47 = Juvenile gang killings
48 = Institutional killings
49 = Sniper attack
50 = Victim shot in hunting accident
51 = Gun-cleaning death - other than self
52 = Children playing with gun
53 = Other negligent handling of gun
59 = All other manslaughter by negligence
60 = Other
70 = All suspected felony type
80 = Felon killed by private citizen
81 = Felon killed by police
99 = Circumstances undetermined
SUBCIRCUM - A single-digit alphanumeric variable describing several conditions in which the victim is reported to have been a criminal offender. (A2). Under the original FBI coding, these conditions are described as:
"A" = "Felon attacked police officer"
"B" = "Felon attacked fellow police officer"
"C" = "Felon attacked a civilian"
"D" = "Felon attempted flight from a crime"
"E" = "Felon killed in commission of a crime"
"F" = "Felon resisted arrest"
FILEDATE - A six-digit alphanumeric variable describing the date a record was reported, not the date of the occurrence of the crime. Note, in some cases, date was not reported and has been estimated. In some cases, the date indicates when local or state police provided the record to MAP. A value of "030180" means the record was reported on March 1, 1980. (A6).
FSTATE - A two-digit alphanumeric variable representing the state in which a homicide was reported. A value of "01" = "Alabama" and "02" = "Alaska" and so forth.
MSA - An eight-digit numeric variable representing the Census Bureau's Federal Information Processing Standards (FIPS) code for the Metropolitan Statistical Area from which a record was reported. When using the Comma Separated Values format file (file extension=.csv) the original FIPS coding is replaced with the label indicating the metropolitan area. (F8.0).

Read other datasets in.  Some information may have to be scraped.
```{r}
#read in states data from base R into dataset
statesData <-
data.frame(state.name, state.abb, state.division, state.region)

#used import.io to scrape FIPS data and put into csv
#will want to use fips codes for crimedata
#https://www.nrcs.usda.gov/wps/portal/nrcs/detail/national/home/?cid=nrcs143_013697
fipsCodes <- read_csv("C:/Users/user/Desktop/fipsCodes.csv")
fipsCodes$Fips <- str_remove(fipsCodes$Fips, "^0+")

#remove first column bc it is the url and not needed in the dataset
fipsCodes$url <- NULL

fipsCodes <- fipsCodes %>%
rename(FIPS = Fips)

#download rural urban codes
#https://www.ers.usda.gov/data-products/rural-urban-continuum-codes.aspx
ruralurbancodes <-
read_excel("C:/Users/user/Desktop/ruralurbancodes2013.xls")
ruralurbancodes$FIPS <- str_remove(ruralurbancodes$FIPS, "^0+")

#remove population
ruralurbancodes$Population_2010 <- NULL
ruralurbancodes <- ruralurbancodes %>%
separate(Description, c("MetroOrNot", "Description"), "-")

RUCDescription <- ruralurbancodes %>%
select(RUCC_2013, MetroOrNot, Description) %>%
distinct()

#arrange in ascending order by description code number
RUCDescription <- RUCDescription %>%
arrange(RUCC_2013)

#make the CNTYFIPS columns in crimeData and fipsCodes DFs more uniform since we will left_join on that column
fipsCodes$Name <- gsub("St ", "St. ", fipsCodes$Name)
fipsCodes$Name <-
gsub("Colonial Heights Cit", "Colonial Heights City", fipsCodes$Name)
crimeData$CNTYFIPS <- gsub("Miami-Dade", "Dade", crimeData$CNTYFIPS)
fipsCodes$CNTYFIPS <-
paste(fipsCodes$Name, fipsCodes$State, sep = ", ")

#left_join
crimeData <- crimeData %>%
left_join(fipsCodes, by = 'CNTYFIPS')

#if there are any differences in the column it will result in an NA in the FIPS column
sum(is.na(crimeData$FIPS))

#missing info so we will inspect why there are so many NAs
#copy df to work with so we do not have to reload entire csv in case we need to start over
crimeDataDF <- crimeData

#determine which rows have NAs and look for patterns
which(is.na(crimeDataDF$FIPS))

#common differences between two tables
crimeDataDF$CNTYFIPS <-
gsub("District of Columbia", "Washington, DC", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("DuPage, IL", "Du Page, IL", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <- gsub(" city", " City", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <- gsub("'", "", crimeDataDF$CNTYFIPS)

#state of virginia  has many counties that do not match up with crime df
crimeDataDF$CNTYFIPS <-
gsub("Alexandria, VA", "Alexandria City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Bedford, VA", "Bedford City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Bristol, VA", "Bristol City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Buena Vista, VA", "Buena Vista City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Charlottesville, VA",
"Charlottesville City, VA",
crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Chesapeake, VA", "Chesapeake City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Clifton Forge, VA",
"Clifton Forge City, VA",
crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Colonial Heights, VA",
"Colonial Heights City, VA",
crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Covington, VA", "Covington City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Danville, VA", "Danville City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Emporia, VA", "Emporia City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Fairfax, VA", "Fairfax City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Falls Church, VA", "Falls Church City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Franklin, VA", "Franklin City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Fredericksburg, VA",
"Fredericksburg City, VA",
crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Galax, VA", "Galax City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Hampton, VA", "Hampton City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Harrisonburg, VA",
"Harrisonburg City, VA",
crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Hopewell, VA", "Hopewell City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Lexington, VA", "Lexington City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Lynchburg, VA", "Lynchburg City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Manassas, VA", "Manassas City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Manassas Park, VA",
"Manassas Park City, VA",
crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Martinsville, VA",
"Martinsville City, VA",
crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Newport News, VA", "Newport News City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Norfolk, VA", "Norfolk City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Norton, VA", "Norton City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Petersburg, VA", "Petersburg City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Poquoson, VA", "Poquoson City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Portsmouth, VA", "Portsmouth City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Radford, VA", "Radford City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Richmond, VA", "Richmond City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Roanoke, VA", "Roanoke City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Salem, VA", "Salem City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("South Boston, VA", "South Boston City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Staunton, VA", "Staunton City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Suffolk, VA", "Suffolk City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Virginia Beach, VA",
"Virginia Beach City, VA",
crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Waynesboro, VA", "Waynesboro City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Williamsburg, VA",
"Williamsburg City, VA",
crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Winchester, VA", "Winchester City, VA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("DeKalb, IL", "De Kalb, IL", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Carson City City, NV", "Carson City, NV", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("DeKalb, ", "De Kalb, ", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Lagrange, IN", "La Grange, IN", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("DeSoto, MS", "De Soto, MS", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("OBrien, IA", "O Brien, IA", crimeDataDF$CNTYFIPS)
crimeDataDF$CNTYFIPS <-
gsub("Broomfield, CO", "Denver, CO", crimeDataDF$CNTYFIPS)

crimeDataDF <- crimeDataDF %>%
left_join(fipsCodes, by = 'CNTYFIPS')

sum(is.na(crimeDataDF$FIPS.y))

#delete columns from first left_join and repeat columns
crimeDataDF$FIPS.x <- NULL
crimeDataDF$Name.x <- NULL
crimeDataDF$State.y <- NULL
crimeDataDF$Name.y <- NULL
crimeDataDF$State <- NULL

#rename columns
crimeDataDF <- crimeDataDF %>%
rename(FIPS = FIPS.y)

crimeDataDF <- crimeDataDF %>%
rename(State = State.x)
```

Let's look more closely at the relationships between the table variables and get rid of repeat information.

```{r}
#can get rid of state and county in ruralurbancodes since information is in fips
ruralurbancodes$State <- NULL
ruralurbancodes$County_Name <- NULL

#we can also get rid of the descriptions in ruralurbancodes since the information is in the RUCDescription table
ruralurbancodes$MetroOrNot <- NULL
ruralurbancodes$Description <- NULL

#rename columns in states data
statesData <- statesData %>%
rename(State = state.abb) %>%
rename(Name = state.name) %>%
rename(Division = state.division) %>%
rename(Region = state.region)

#now that we have a FIPS code in both fipsCodes and crimeDataDF we can get rid of some redundancy in the crimeDataDF
crimeDataDF$MSA <- NULL
crimeDataDF$CNTYFIPS <- NULL

#change column "Name" to "County" in fipsCodes
fipsCodes <- fipsCodes %>%
rename(County = Name)

#the ori is contained in the unique id so we do not need to repeat it in a separate column
crimeDataDF$Ori <- NULL

fipsCodes$County <- NULL
```

We can change some of the variables from characters to factors since they are categorical variables.  
```{r}
crimeDataDF$Agentype <- as.factor(crimeDataDF$Agentype)
crimeDataDF$Solved <- as.factor(crimeDataDF$Solved)
crimeDataDF$Source <- as.factor(crimeDataDF$Source)
crimeDataDF$ActionType <- as.factor(crimeDataDF$ActionType)
crimeDataDF$Homicide <- as.factor(crimeDataDF$Homicide)
crimeDataDF$Situation <- as.factor(crimeDataDF$Situation)
crimeDataDF$VicSex <- as.factor(crimeDataDF$VicSex)
crimeDataDF$OffSex <- as.factor(crimeDataDF$OffSex)
crimeDataDF$VicEthnic <- as.factor(crimeDataDF$VicEthnic)
crimeDataDF$VicRace <- as.factor(crimeDataDF$VicRace)
crimeDataDF$OffEthnic <- as.factor(crimeDataDF$OffEthnic)
crimeDataDF$OffRace <- as.factor(crimeDataDF$OffRace)
crimeDataDF$Weapon <- as.factor(crimeDataDF$Weapon)
crimeDataDF$Relationship <- as.factor(crimeDataDF$Relationship)
crimeDataDF$Circumstance <- as.factor(crimeDataDF$Circumstance)

#each case will need a unique ID for sql
crimeDataDF$ID <- seq.int(nrow(crimeDataDF))

#rename statesData columns
statesData <- statesData %>%
rename(Abb = State) %>%
rename(State = Name)
```

Use SQL to store tables with primary and foreign keys
```{r}
library(RSQLite)

#database for Fips unemployment and education
database<-dbConnect(SQLite(),dbname="Crime.sqlite")

#create table for rural urban code with primary key as the code
dbSendQuery(database, "CREATE TABLE RUCDescription
(
  RUCC_2013 INTEGER PRIMARY KEY, 
  MetroOrNot TEXT,
  Description TEXT
)")
dbWriteTable(database, "RUCDescription", RUCDescription, append=TRUE, row.names=FALSE)

#create table for rural urban codes and fips
dbSendQuery(database, "CREATE TABLE ruralurbancodes
(
  FIPS INTEGER PRIMARY KEY, 
  RUCC_2013 INTEGER,
  FOREIGN KEY (RUCC_2013) REFERENCES RUCDescription(RUCC_2013)
)")
dbWriteTable(database, "ruralurbancodes", ruralurbancodes, append=TRUE, row.names=FALSE)

#create table for rural urban codes and fips
dbSendQuery(database, "CREATE TABLE crimeDataDF
(
  ID INTEGER PRIMARY KEY, 
  State TEXT,
  Agency TEXT,
  AgenType TEXT,
  Source TEXT,
  Solved TEXT,
  Year INTEGER,
  Month TEXT,
  Incident INTEGER,
  ActionType TEXT,
  Homicide TEXT,
  Situation TEXT,
  VicAge INTEGER,
  VicSex TEXT,
  VicRace TEXT,
  VicEthnic TEXT,
  OffAge INTEGER,
  OffSex TEXT, 
  OffRace TEXT,
  OffEthnic TEXT,
  Weapon TEXT,
  Relationship TEXT,
  Circumstance TEXT,
  Subcircum TEXT,
  VicCount INTEGER,
  OffCount INTEGER,
  FileDate INTEGER,
  fstate TEXT,
  FIPS INTEGER,
  FOREIGN KEY (FIPS) REFERENCES ruralurbancodes(FIPS)
)")
dbWriteTable(database, "crimeDataDF", crimeDataDF, append=TRUE, row.names=FALSE)

#Create table for fips codes that references crimeDataDF
dbSendQuery(database, "CREATE TABLE fipsCodes
(
  FIPS INTEGER,
  State TEXT,
  CNTYFIPS TEXT PRIMARY KEY,
  FOREIGN KEY (FIPS) REFERENCES CrimeDataDF(FIPS)
)")
dbWriteTable(database, "fipsCodes", fipsCodes, append=TRUE, row.names=FALSE)

#Create table for states data that references fipsCodes
dbSendQuery(database, "CREATE TABLE statesData
(
  State TEXT,
  Abb TEXT PRIMARY KEY,
  Division TEXT,
  Region TEXT, 
  FOREIGN KEY (State) REFERENCES crimeDataDF(State)
)")
dbWriteTable(database, "statesData", statesData, append=TRUE, row.names=FALSE)
```

Examples of data retrieval from SQL

```{r error=TRUE}
#select the unique ID and the Agency Type for cases in Birmingham, Alabama in 1976
query <-
dbSendQuery(
database,
"Select [ID], [AgenType] from crimeDataDF
WHERE [Year]=1976
AND [State]='Alabama'
AND [Agency]='Birmingham'"
)
dbFetch(query)

#Which sex is most often a victim
query <- dbSendQuery(
database,
"Select [VicSex], Count(*)
FROM crimeDataDF
GROUP BY [VicSex]
ORDER BY COUNT(*) DESC"
)
dbFetch(query)

#Which sex is most often an offender
query <- dbSendQuery(
database,
"Select [OffSex], Count(*)
FROM crimeDataDF
GROUP BY [OffSex]
ORDER BY COUNT(*) DESC"
)
dbFetch(query)

#select region with most unsolved cases in the US
query <- dbSendQuery(
database,
"SELECT [Solved], [Region], COUNT(*)
FROM crimeDataDF
INNER JOIN statesData on statesData.State = crimeDataDF.State
WHERE [Solved] =  'No'
GROUP BY [Region]
ORDER BY COUNT(*) DESC"
)
dbFetch(query)

#frequency per region of murders committed with a shotgun
query <- dbSendQuery(
database,
"SELECT [Weapon], [Region], COUNT(*)
FROM crimeDataDF
INNER JOIN statesData on statesData.State = crimeDataDF.State
WHERE [Weapon] = 'Shotgun'
GROUP BY [Region]
ORDER BY COUNT(*) DESC"
)
dbFetch(query)

#frequency per region of murders committed with a handgun
query <- dbSendQuery(
database,
"SELECT [Weapon], [Region], COUNT(*)
FROM crimeDataDF
INNER JOIN statesData on statesData.State = crimeDataDF.State
WHERE [Weapon] = 'Handgun - pistol, revolver, etc'
GROUP BY [Region]
ORDER BY COUNT(*) DESC
"
)
dbFetch(query)

#frequency of weapons used in each region
query <- dbSendQuery(
database,
"SELECT [Weapon], [Region], COUNT(*)
FROM crimeDataDF
INNER JOIN statesData on statesData.State = crimeDataDF.State
GROUP BY [Region], [Weapon]
ORDER BY COUNT(*) DESC
"
)
dbFetch(query)

#solved and unsolved rates per race in each region
query <-
dbSendQuery(
database,
"SELECT [VicRace], [Solved], [Region], COUNT(*)
FROM crimeDataDF
INNER JOIN statesData on statesData.State = crimeDataDF.State
GROUP BY [Region], [VicRace], [Solved]
ORDER BY COUNT(*) DESC
"
)
dbFetch(query)

#solved and unsolved rates per region
query <-
dbSendQuery(
database,
"SELECT [Year], [Solved], [Region], COUNT(*)
FROM crimeDataDF
INNER JOIN statesData on statesData.State = crimeDataDF.State
GROUP BY [Region], [Year], [Solved]
ORDER BY COUNT(*) DESC
"
)
dbFetch(query)

#cases per year for each state
query <- dbSendQuery(
database,
"SELECT [Year], [State], COUNT(*)
FROM crimeDataDF
GROUP BY [State], [Year]
ORDER BY COUNT(*) DESC
"
)
dbFetch(query)

#california lead in number of cases for many of the years. we will look further analyze

#investigate rates of the relationship to the victim for females by state
query <-
dbSendQuery(
database,
"SELECT [State], [Solved], [VicSex], [Relationship], COUNT(*)
FROM crimeDataDF
WHERE [Solved] = 'No'
And [VicSex] = 'Female'
GROUP BY [State], [Relationship]
ORDER BY COUNT(*) DESC
"
)
dbFetch(query)

#narrow it down to unsolved cases  in california where the victim is female and the relationship to the offender is not known.  group by year and weapon used.
query <-
dbSendQuery(
database,
"SELECT [State], [Year], [Solved], [VicSex], [VicRace], [Relationship], [Weapon], COUNT(*)
FROM crimeDataDF
WHERE [State] = 'California'
AND [Solved] = 'No'
And [VicSex] = 'Female'
AND [Relationship] = 'Relationship not determined'
GROUP BY [Year], [VicRace], [Weapon]
ORDER BY [Year] DESC
"
)
dbFetch(query)

#investigate solved cases per sex and race
query <-
dbSendQuery(
database,
"SELECT [Solved], [VicSex], [VicRace], COUNT(*)
FROM crimeDataDF
WHERE [Solved] = 'Yes'
GROUP BY [VicSex], [VicRace]
ORDER BY COUNT(*) DESC
"
)
dbFetch(query)

#add region to previous query
query <-
dbSendQuery(
database,
"SELECT [Region], [Solved], [VicSex], [VicRace], COUNT(*)
FROM crimeDataDF
INNER JOIN statesData on statesData.State = crimeDataDF.State
WHERE [Solved] = 'Yes'
GROUP BY [VicSex], [VicRace], [Region]
ORDER BY COUNT(*) DESC"
)
dbFetch(query)

#total murders per region grouped by victim sex and race
query <-
dbSendQuery(
database,
"SELECT [Region], [VicSex], [VicRace], COUNT(*)
FROM crimeDataDF
INNER JOIN statesData on statesData.State = crimeDataDF.State
GROUP BY [VicSex], [VicRace], [Region]
ORDER BY COUNT(*) DESC"
)
dbFetch(query)

#using the information from the previous two queries, the south has the most murders as a region.  the solved rate for the two most frequent vicRaces can be calculated.

#South solved
# Black    98240
# White    85108

#South total
# Black   134430
# White   108150

#Solved rates total 79% for White males and 73% for Black males overall US
```

Further Analysis and Visualizations
```{r}
#example of looking at patterns in a state 
#narrow it down to unsolved cases  in california where the victim is female and the relationship to the offender is not known.  group by race, year and weapon used.
query <-
dbSendQuery(
database,
"SELECT [State], [Year], [Solved], [VicSex], [VicRace], [Relationship], [Weapon], COUNT(*)
FROM crimeDataDF
WHERE [State] = 'California'
AND [Solved] = 'No'
And [VicSex] = 'Female'
AND [Relationship] = 'Relationship not determined'
GROUP BY  [Year], [VicRace], [Weapon]
ORDER BY [Year] DESC
"
)
df<-dbFetch(query)

plot_df<-df %>% 
    select(Year, Weapon, `COUNT(*)`) %>%
    group_by(Year) %>%
    do(
      plots = ggplot() + 
        geom_line(data = ., aes(x = `COUNT(*)`, y = Weapon), color = "blue") + ggtitle(.$Year))

plot_df$plots

#visualize unsolved murder count by vicRace
plot_df<-df %>% 
    select(Year, VicRace, `COUNT(*)`) %>%
    group_by(Year) %>%
    do(
      plots = ggplot() + 
        geom_line(data = ., aes(x = `COUNT(*)`, y = VicRace), color = "blue") + ggtitle(.$Year))

plot_df$plots

#investigate murder trend by year against women in the US
query <-
dbSendQuery(
database,
"SELECT [Year], [VicSex], COUNT(*)
FROM crimeDataDF
WHERE [VicSex] = 'Female'
GROUP BY [Year]
ORDER BY [Year]
"
)
df<-dbFetch(query)

ggplot(df, aes(Year, `COUNT(*)`)) +
  geom_point() +
  geom_line()

#investigate murder trend by year against women in the US per state
query <-
dbSendQuery(
database,
"SELECT [Year], [State], [VicSex], COUNT(*)
FROM crimeDataDF
WHERE [VicSex] = 'Female'
GROUP BY [Year], [State]
ORDER BY [Year]
"
)
df<-dbFetch(query)

plot_df<-df %>% 
    select(Year, State, `COUNT(*)`) %>%
    group_by(State) %>%
    do(
      plots = ggplot() + 
        geom_line(data = ., aes(x = Year, y = `COUNT(*)`), color = "blue") + ggtitle(.$State))

plot_df$plots
```

